const bcrypt = require("bcrypt");
const { validationResult } = require("express-validator");
const { checkStudentNumberExists, registerStudent, getAllStudents, getStudentById, updateStudent, softDeleteStudent, restoreStudent, resetStudentPassword, deleteStudentPermanently, unlockStudentAccount, processBatchStudents } = require("../models/studentModel");
const XLSX = require('xlsx');
const fs = require('fs');
const path = require('path');
const pool = require("../config/db");


const generateStudentPassword = (lastName, studentNumber) => {
  const lastThreeDigits = studentNumber.slice(-3);
  const specialCharacter = "!";
  return `${lastName}${lastThreeDigits}${specialCharacter}`;
}

const isValidStudentEmail = (email, studentNumber, lastName) => {
  const lastSixDigits = studentNumber.slice(-6); 
  const expectedEmail = `${lastName.toLowerCase()}.${lastSixDigits}@novaliches.sti.edu.ph`;
  return email.toLowerCase() === expectedEmail;
};

// Add this utility function for normalizing names and email generation
const normalizeForEmail = (text) => {
  if (!text) return '';
  
  // Remove spaces and convert to lowercase
  let normalized = text.toLowerCase().replace(/\s+/g, '');
  
  // Replace Spanish characters with their ASCII equivalents
  const charMap = {
    'á': 'a', 'é': 'e', 'í': 'i', 'ó': 'o', 'ú': 'u',
    'ü': 'u', 'ñ': 'n', 'ç': 'c', 'à': 'a', 'è': 'e',
    'ì': 'i', 'ò': 'o', 'ù': 'u'
  };
  
  return normalized.replace(/[áéíóúüñçàèìòù]/g, match => charMap[match] || match);
};

exports.registerStudent = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { firstName, middleName, lastName, email, studentNumber, courseName, courseId, yearLevel, gender, birthdate, password, createdBy } = req.body;

    // Check if student number already exists
    const studentExists = await checkStudentNumberExists(studentNumber);
    if (studentExists) {
      return res.status(400).json({ message: "Student number already exists" });
    }

    // Password hash
    let hashedPassword;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
    } else {
      const autoGeneratedPassword = generateStudentPassword(lastName, studentNumber);
      hashedPassword = await bcrypt.hash(autoGeneratedPassword, 10);
    }

    // Process middleName - allow empty string, null, or single character
    let processedMiddleName = null;
    if (middleName !== undefined && middleName !== null) {
      const middleNameStr = String(middleName).trim();
      if (middleNameStr.length > 0) {
        processedMiddleName = middleNameStr;
      }
    }

    // Process birthdate
    let processedBirthdate = null;
    if (birthdate) {
      try {
        processedBirthdate = new Date(birthdate);
        if (isNaN(processedBirthdate.getTime())) {
          return res.status(400).json({ message: "Invalid birthdate format" });
        }
      } catch (error) {
        return res.status(400).json({ message: "Invalid birthdate format" });
      }
    }

    // Use provided email or generate normalized email
    let studentEmail = email;
    if (!studentEmail) {
      // Generate email with spaces removed from lastName and special characters normalized
      const normalizedLastName = normalizeForEmail(lastName);
      const lastSixDigits = studentNumber.slice(-6);
      studentEmail = `${normalizedLastName}.${lastSixDigits}@novaliches.sti.edu.ph`;
    }

    // Register student
    const student = await registerStudent(
      firstName,
      processedMiddleName,
      lastName,
      studentEmail,
      studentEmail, // Using email as username
      hashedPassword,
      studentNumber,
      courseName,
      yearLevel,
      gender,
      processedBirthdate,
      createdBy,
      courseId
    );

    res.status(201).json({
      success: true,
      message: "Student registered successfully",
      student,
    });
  } catch (error) {
    console.error("Registration Error:", error);
    
    let errorMessage = error.message;
    
    // Enhanced error handling for database constraints
    if (error.code === '23503' && error.constraint === 'students_course_name_fkey') {
      errorMessage = `The course '${req.body.courseName}' does not exist in the database. Please add it first or use a valid course.`;
    }
    
    res.status(500).json({
      message: "Failed to register student",
      error: errorMessage,
    });
  }
};

exports.getAllStudents = async (req, res) => {
  try {
    const students = await getAllStudents();
    res.status(200).json({ students });
  } catch (error) {
    console.error("Error fetching students:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.getStudentById = async (req, res) => {
  try {
    const studentId = req.params.id;
    const student = await getStudentById(studentId);

    if (!student) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ student });
  } catch (error) {
    console.error("Error fetching student by ID:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.editStudent = async (req, res) => {
  try {
    const studentId = req.params.id;
    const { firstName, middleName, lastName, courseName, yearLevel, gender, birthdate } = req.body;

    if (!firstName || !lastName || !courseName || !yearLevel || !gender) {
      return res.status(400).json({ message: "All required fields must be provided" });
    }

    const updatedStudent = await updateStudent(studentId, firstName, middleName, lastName, courseName, yearLevel, gender, birthdate ? new Date(birthdate) : null);

    if (!updatedStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student updated successfully", student: updatedStudent });
  } catch (error) {
    console.error("Error updating student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.deleteStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const deletedStudent = await softDeleteStudent(studentId);
    if (!deletedStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student deleted successfully (soft delete)", student: deletedStudent });
  } catch (error) {
    console.error("Error deleting student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.restoreStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const restoredStudent = await restoreStudent(studentId);
    if (!restoredStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student restored successfully", student: restoredStudent });
  } catch (error) {
    console.error("Error restoring student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.resetStudentPassword = async (req, res) => {
  try {
    const { studentId, newPassword } = req.body;

    if (!studentId || !newPassword) {
      return res.status(400).json({ message: "Student ID and new password are required." });
    }

    const passwordRegex = /^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    if (!passwordRegex.test(newPassword)) {
      return res.status(400).json({ message: "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character." });
    }

    const updatedStudent = await resetStudentPassword(studentId, newPassword);
    if (!updatedStudent) {
      return res.status(404).json({ message: "Student not found or not linked to a user." });
    }

    res.status(200).json({ message: "Student password reset successfully", student: updatedStudent });
  } catch (error) {
    console.error("Error resetting student password:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.permanentDeleteStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const deletedStudent = await deleteStudentPermanently(studentId);
    if (!deletedStudent) {
      return res.status(404).json({ message: "Student not found or already deleted permanently." });
    }

    res.status(200).json({ message: "Student permanently deleted." });
  } catch (error) {
    console.error("Error permanently deleting student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.unlockStudentAccount = async (req, res) => {
  try {
    const studentId = req.params.id;
    const unlockedAccount = await unlockStudentAccount(studentId);
    
    if (!unlockedAccount) {
      return res.status(404).json({ message: "Student not found" });
    }
    
    res.status(200).json({ message: "Student account unlocked successfully" });
  } catch (error) {
    console.error("Error unlocking student account:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.uploadStudentsBatch = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
    if (!req.body.createdBy) {
      return res.status(400).json({ message: 'Super Admin ID is required' });
    }

    const filePath = path.resolve(req.file.path);
    
    if (!fs.existsSync(filePath)) {
      throw new Error('Uploaded file not found');
    }

    // Read the Excel file
    console.log("Reading Excel file:", filePath);
    
    const workbook = XLSX.read(fs.readFileSync(filePath));
    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
    let jsonData = XLSX.utils.sheet_to_json(worksheet);

    // Check if we have any data
    if (jsonData.length === 0) {
      return res.status(400).json({ message: 'Excel file contains no data' });
    }

    console.log("Raw data from Excel:", JSON.stringify(jsonData.slice(0, 2))); // Log first 2 rows for debugging

    // Normalize column names to handle different cases and variations
    jsonData = jsonData.map(row => {
      const normalizedRow = {};
      
      // Debug log
      console.log("Processing row with keys:", Object.keys(row));
      
      // Process each key in the row
      Object.keys(row).forEach(key => {
        // Normalize by converting to lowercase and removing spaces
        const normalizedKey = key.toLowerCase().replace(/\s+/g, '');
        console.log(`Normalized key: '${key}' -> '${normalizedKey}'`);
        
        // Map various possible column names to our expected format
        if (normalizedKey === 'firstname' || normalizedKey === 'first' || normalizedKey === 'fname') {
          normalizedRow.firstName = row[key];
        } else if (normalizedKey === 'middlename' || normalizedKey === 'middle' || normalizedKey === 'mname') {
          normalizedRow.middleName = row[key];
        } else if (normalizedKey === 'lastname' || normalizedKey === 'last' || normalizedKey === 'lname') {
          normalizedRow.lastName = row[key];
        } else if (normalizedKey === 'studentnumber' || normalizedKey === 'studentno' || normalizedKey === 'idnumber' || normalizedKey === 'id') {
          normalizedRow.studentNumber = String(row[key]); // Ensure it's a string
        } else if (normalizedKey === 'coursename' || normalizedKey === 'course' || normalizedKey === 'program') {
          normalizedRow.courseName = row[key];
        } else if (normalizedKey === 'yearlevel' || normalizedKey === 'year' || normalizedKey === 'level') {
          normalizedRow.yearLevel = row[key];
        } else if (normalizedKey === 'gender' || normalizedKey === 'sex') {
          normalizedRow.gender = row[key];
        } else if (normalizedKey === 'birthdate' || normalizedKey === 'birthday' || normalizedKey === 'dob' || normalizedKey === 'birth') {
          normalizedRow.birthdate = row[key];
        } else if (normalizedKey === 'email') {
          normalizedRow.email = row[key];
        } else {
          // For any other fields, keep them as is
          normalizedRow[key] = row[key];
        }
      });
      
      return normalizedRow;
    });

    console.log("Normalized data sample:", JSON.stringify(jsonData.slice(0, 2)));

    // Validate required fields in the normalized data and fix any issues where possible
    const requiredFields = ['firstName', 'lastName', 'studentNumber', 'courseName', 'yearLevel', 'gender'];
    const invalidRows = [];
    const validatedData = [];
    
    jsonData.forEach((student, index) => {
      const missingFields = [];
      const rowNum = index + 2; // +2 because Excel is 1-indexed and we have a header row
      
      // Check for missing required fields
      requiredFields.forEach(field => {
        if (student[field] === undefined || student[field] === null || String(student[field]).trim() === '') {
          missingFields.push(field);
        }
      });
      
      // Log issue for debugging
      if (missingFields.length > 0) {
        console.log(`Row ${rowNum} is missing fields:`, missingFields, "Row data:", student);
        
        invalidRows.push({
          row: rowNum,
          studentNumber: student.studentNumber || 'Unknown',
          firstName: student.firstName || 'Unknown',
          lastName: student.lastName || 'Unknown',
          error: `Missing required fields: ${missingFields.join(', ')}`
        });
      } else {
        // Continue validation for rows that have all required fields
        
        // Validate student number format
        if (student.studentNumber && !/^02000[0-9]{6}$/.test(student.studentNumber)) {
          invalidRows.push({
            row: rowNum,
            studentNumber: student.studentNumber,
            firstName: student.firstName || 'Unknown',
            lastName: student.lastName || 'Unknown',
            error: 'Invalid student number format. Must be 11 digits starting with 02000'
          });
          return; // Skip this row
        }
        
        // Generate proper email with normalized lastName (spaces and special chars removed)
        if (!student.email) {
          const normalizedLastName = normalizeForEmail(student.lastName);
          const lastSixDigits = student.studentNumber.slice(-6);
          student.email = `${normalizedLastName}.${lastSixDigits}@novaliches.sti.edu.ph`;
          console.log(`Generated email for ${student.firstName} ${student.lastName}: ${student.email}`);
        }
        
        // Validate and normalize year level
        if (student.yearLevel) {
          // Convert to string in case it's a number
          const yearLevelStr = String(student.yearLevel).trim();
          
          // Try to extract the year number various ways
          let year = null;
          
          // Check if it starts with a number (e.g., "1st Year", "1Y", "1", etc.)
          const startsWithNumberMatch = yearLevelStr.match(/^(\d)/);
          if (startsWithNumberMatch) {
            year = parseInt(startsWithNumberMatch[1]);
          } 
          // Check for spelled out years
          else if (yearLevelStr.toLowerCase().includes('first') || yearLevelStr.toLowerCase().includes('1st')) {
            year = 1;
          }
          else if (yearLevelStr.toLowerCase().includes('second') || yearLevelStr.toLowerCase().includes('2nd')) {
            year = 2;
          }
          else if (yearLevelStr.toLowerCase().includes('third') || yearLevelStr.toLowerCase().includes('3rd')) {
            year = 3;
          }
          else if (yearLevelStr.toLowerCase().includes('fourth') || yearLevelStr.toLowerCase().includes('4th')) {
            year = 4;
          }
          
          // Map to standard format
          if (year >= 1 && year <= 4) {
            const yearLevelMap = {
              1: "1st Year",
              2: "2nd Year",
              3: "3rd Year",
              4: "4th Year"
            };
            student.yearLevel = yearLevelMap[year];
          } else {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: `Invalid year level: "${yearLevelStr}". Must be 1st-4th Year or contain a digit 1-4.`
            });
            return; // Skip this row
          }
        }
        
        // Validate gender - be more flexible with capitalization
        if (student.gender) {
          const normalizedGender = student.gender.toString().trim().toLowerCase();
          if (normalizedGender === 'male' || normalizedGender === 'm') {
            student.gender = 'Male'; // Normalize to proper case
          } else if (normalizedGender === 'female' || normalizedGender === 'f') {
            student.gender = 'Female'; // Normalize to proper case
          } else {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: 'Invalid gender. Must be either "Male" or "Female"'
            });
            return; // Skip this row
          }
        }
        
        // Validate birthdate if provided
        if (student.birthdate) {
          try {
            const date = new Date(student.birthdate);
            if (isNaN(date.getTime())) {
              invalidRows.push({
                row: rowNum,
                studentNumber: student.studentNumber,
                firstName: student.firstName || 'Unknown',
                lastName: student.lastName || 'Unknown',
                error: 'Invalid birthdate format'
              });
              return; // Skip this row
            }
          } catch (e) {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: 'Invalid birthdate format'
            });
            return; // Skip this row
          }
        }
        
        // This row passed all validations
        validatedData.push(student);
      }
    });
    
    console.log(`Found ${invalidRows.length} invalid rows and ${validatedData.length} valid rows`);
    
    if (validatedData.length === 0 && invalidRows.length > 0) {
      return res.status(400).json({
        message: 'All rows in the Excel file contain errors',
        errors: invalidRows
      });
    }

    // Collect all unique course names from the batch data
    const uniqueCourseNames = new Set();
    validatedData.forEach(student => {
      if (student.courseName) {
        uniqueCourseNames.add(student.courseName.trim());
      }
    });

    // Add all missing courses to the database first
    if (uniqueCourseNames.size > 0) {
      // Get existing courses
      const existingCoursesResult = await pool.query(
        "SELECT course_name FROM courses"
      );
      const existingCourses = new Set(
        existingCoursesResult.rows.map(course => course.course_name.toLowerCase())
      );

      // Insert any missing courses
      for (const courseName of uniqueCourseNames) {
        if (!existingCourses.has(courseName.toLowerCase())) {
          try {
            await pool.query(
              "INSERT INTO courses (course_name) VALUES ($1) ON CONFLICT DO NOTHING",
              [courseName]
            );
            console.log(`Added new course: ${courseName}`);
          } catch (error) {
            console.error(`Failed to add course ${courseName}:`, error);
          }
        }
      }
    }

    // Now process the batch with all courses in the database
    console.log(`Processing batch with ${validatedData.length} students`);
    const result = await processBatchStudents(validatedData, req.body.createdBy);

    try {
      fs.unlinkSync(filePath);
    } catch (unlinkError) {
      console.error('Error deleting temp file:', unlinkError);
    }

    // Combine invalid rows with any errors during processing
    const allErrors = [...invalidRows];
    if (result.errors && result.errors.length > 0) {
      allErrors.push(...result.errors);
    }

    res.status(200).json({
      message: 'Batch upload processed',
      total: jsonData.length,
      success: result.success,
      failed: invalidRows.length + result.failed,
      errors: allErrors
    });
  } catch (error) {
    console.error('Error processing batch upload:', error);
    res.status(500).json({ 
      message: 'Error processing batch upload',
      error: error.message,
      stack: error.stack  // Include stack trace for debugging
    });
  }
};

exports.getStudentElections = async (req, res) => {
  try {
    console.log("Student elections requested by user:", req.user);

    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      console.log("No user ID found in token");
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
    
    console.log("Looking up elections for studentId:", studentId, "userId:", userId);
    
 
    let studentResult;
    
    try {
 
      if (studentId) {
        console.log("Attempting to find student by studentId:", studentId);
        studentResult = await pool.query(`
          SELECT id FROM students WHERE id = $1 AND is_active = TRUE
        `, [studentId]);
      }
      

      if (!studentId || studentResult.rows.length === 0) {
        console.log("Trying to find student by user_id:", userId);
        studentResult = await pool.query(`
          SELECT s.id 
          FROM students s
          JOIN users u ON s.email = u.email
          WHERE u.id = $1 AND s.is_active = TRUE
        `, [userId]);
      }
      
      if (studentResult.rows.length === 0) {
        console.log("No student record found for user");
        return res.status(404).json({ message: "Student record not found for this user" });
      }
      
      const actualStudentId = studentResult.rows[0].id;
      console.log("Found student with ID:", actualStudentId);
  
      const elections = await pool.query(`
        SELECT 
          e.id, e.title, e.description, 
          e.date_from, e.date_to,
          e.start_time, e.end_time,
          e.status,
          ev.has_voted,
          (SELECT COUNT(*) FROM eligible_voters WHERE election_id = e.id) AS voter_count,
          (SELECT COUNT(*) FROM eligible_voters WHERE election_id = e.id AND has_voted = TRUE) AS vote_count,
          EXISTS (
            SELECT 1 FROM ballots b 
            WHERE b.election_id = e.id
          ) AS ballot_exists
        FROM elections e
        INNER JOIN eligible_voters ev ON e.id = ev.election_id
        WHERE ev.student_id = $1
        AND (e.needs_approval = FALSE OR e.needs_approval IS NULL)
        ORDER BY 
          CASE 
            WHEN e.status = 'ongoing' THEN 1
            WHEN e.status = 'upcoming' THEN 2
            ELSE 3
          END, 
          e.date_from
      `, [actualStudentId]);
      

      const result = elections.rows.map(election => ({
        ...election,
        has_voted: election.has_voted
      }));
      
      console.log(`Found ${result.length} elections for student`);
      return res.json(result);
      
    } catch (err) {
      console.error("Database error in getStudentElections:", err);
      return res.status(500).json({ error: 'Database error: ' + err.message });
    }
  } catch (err) {
    console.error("General error in getStudentElections:", err);
    return res.status(500).json({ error: 'Failed to fetch elections: ' + err.message });
  }
};

exports.getStudentProfile = async (req, res) => {
  try {
    console.log("Student profile requested by user:", req.user);

    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      console.log("No user ID found in token");
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
    
    console.log("Looking up profile for studentId:", studentId, "userId:", userId);
    
    let result;
    
    try {

      if (studentId) {
        result = await pool.query(`
          SELECT 
            s.id, 
            s.first_name AS "firstName", 
            s.middle_name AS "middleName",
            s.last_name AS "lastName", 
            s.email, 
            s.student_number AS "studentNumber", 
            s.course_name AS "courseName", 
            s.year_level AS "yearLevel", 
            s.gender,
            s.birthdate,
            s.profile_picture,
            COUNT(DISTINCT ev.election_id) AS "totalEligibleElections",
            SUM(CASE WHEN ev.has_voted = TRUE THEN 1 ELSE 0 END) AS "votedElections"
          FROM students s
          LEFT JOIN eligible_voters ev ON s.id = ev.student_id
          WHERE s.id = $1 AND s.is_active = TRUE
          GROUP BY s.id
        `, [studentId]);
      }
      
 
      if (!studentId || result.rows.length === 0) {
        console.log("Trying to find student profile by user_id:", userId);
        result = await pool.query(`
          SELECT 
            s.id, 
            s.first_name AS "firstName", 
            s.middle_name AS "middleName",
            s.last_name AS "lastName", 
            s.email, 
            s.student_number AS "studentNumber", 
            s.course_name AS "courseName", 
            s.year_level AS "yearLevel", 
            s.gender,
            s.birthdate,
            s.profile_picture,
            COUNT(DISTINCT ev.election_id) AS "totalEligibleElections",
            SUM(CASE WHEN ev.has_voted = TRUE THEN 1 ELSE 0 END) AS "votedElections"
          FROM students s
          LEFT JOIN eligible_voters ev ON s.id = ev.student_id
          WHERE s.user_id = $1 AND s.is_active = TRUE
          GROUP BY s.id
        `, [userId]);
      }
      
      if (result.rows.length === 0) {
        console.log("No student profile found for user");
        return res.status(404).json({ message: "Student profile not found" });
      }

      const profile = result.rows[0];
      if (profile.profile_picture) {
        profile.profile_picture = `/uploads/profiles/${profile.profile_picture}`;
      }
      
      console.log("Found student profile:", profile.firstName, profile.lastName);
      return res.status(200).json(profile);
      
    } catch (err) {
      console.error("Database error in getStudentProfile:", err);
      return res.status(500).json({ message: "Database error: " + err.message });
    }
  } catch (error) {
    console.error("General error in getStudentProfile:", error);
    return res.status(500).json({ message: "Failed to fetch student profile: " + error.message });
  }
};

exports.uploadProfilePicture = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }

    console.log("File uploaded:", req.file.filename);

    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
  
    let studentResult;
    
    try {
    
      if (studentId) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE id = $1 AND is_active = TRUE
        `, [studentId]);
      }
      
      if (!studentId || studentResult.rows.length === 0) {
        console.log("Trying to find student by user_id:", userId);
        studentResult = await pool.query(`
          SELECT id FROM students WHERE user_id = $1 AND is_active = TRUE
        `, [userId]);
      }
      
      if (studentResult.rows.length === 0) {
        console.log("No student record found for user");
        return res.status(404).json({ message: "Student record not found for this user" });
      }
      
      const actualStudentId = studentResult.rows[0].id;
      
      await pool.query(`
        UPDATE students 
        SET profile_picture = $1 
        WHERE id = $2
      `, [req.file.filename, actualStudentId]);
      
      const filePath = `/uploads/profiles/${req.file.filename}`;
      
      return res.json({ success: true, filePath });
    } catch (err) {
      console.error("Database error in uploadProfilePicture:", err);
      return res.status(500).json({ message: "Database error: " + err.message });
    }
  } catch (error) {
    console.error("Error uploading file:", error);
    return res.status(500).json({ message: "Server error", error });
  }
};

exports.getStudentsByCourses = async (req, res) => {
  try {
   
    const { courses } = req.query;
    
    if (!courses) {
      return res.status(400).json({ success: false, message: "Courses parameter is required" });
    }
    
    // Split the comma-separated course list
    const courseList = courses.split(',').map(course => course.trim());
    
    if (courseList.length === 0) {
      return res.status(400).json({ success: false, message: "At least one course must be provided" });
    }

    const courseRegex = /^[a-zA-Z0-9\s\-_.,()]{1,100}$/;
    for (const course of courseList) {
      if (!courseRegex.test(course)) {
        return res.status(400).json({ 
          success: false, 
          message: `Invalid course name format: ${course}. Only alphanumeric characters, spaces, and common punctuation are allowed.` 
        });
      }
    }
  
    let query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.middle_name,
        s.last_name, 
        s.email, 
        s.student_number, 
        s.course_name, 
        s.year_level, 
        s.gender, 
        s.birthdate,
        s.is_active,
        u.is_locked,
        u.locked_until
      FROM students s
      JOIN users u ON s.user_id = u.id
      WHERE s.course_name IN (`;
    
    // Create parameterized query with proper indices
    const placeholders = courseList.map((_, index) => `$${index + 1}`).join(',');
    query += `${placeholders}) ORDER BY s.last_name ASC`;
    
    const result = await pool.query(query, courseList);
    
    return res.status(200).json(result.rows);
  } catch (error) {
    console.error("Error fetching students by courses:", error);
    return res.status(500).json({ 
      success: false, 
      message: "Failed to fetch students by courses",
      error: error.message 
    });
  }
};
