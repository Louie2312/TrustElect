const bcrypt = require("bcryptjs");
// const { validationResult } = require("express-validator"); // Removed - using route validation instead
const { checkStudentNumberExists, registerStudent, getAllStudents, getStudentById, updateStudent, softDeleteStudent, restoreStudent, resetStudentPassword, deleteStudentPermanently, bulkDeleteStudentsByCourse, bulkDeleteArchivedStudentsByCourse, unlockStudentAccount, processBatchStudents, changePassword } = require("../models/studentModel");
const XLSX = require('xlsx');
const fs = require('fs');
const path = require('path');
const pool = require("../config/db");


const generateStudentPassword = (lastName, studentNumber) => {
  const lastThreeDigits = studentNumber.slice(-3);
  const specialCharacter = "!";
  return `${lastName}${lastThreeDigits}${specialCharacter}`;
}

const isValidStudentEmail = (email, studentNumber, lastName) => {
  const lastSixDigits = studentNumber.slice(-6); 
  const expectedEmail = `${lastName.toLowerCase()}.${lastSixDigits}@novaliches.sti.edu.ph`;
  return email.toLowerCase() === expectedEmail;
};

const normalizeForEmail = (text) => {
  if (!text) return '';

  let normalized = text.toLowerCase().replace(/\s+/g, '');
  
  // Replace Spanish characters with their ASCII equivalents
  const charMap = {
    'á': 'a', 'é': 'e', 'í': 'i', 'ó': 'o', 'ú': 'u',
    'ü': 'u', 'ñ': 'n', 'ç': 'c', 'à': 'a', 'è': 'e',
    'ì': 'i', 'ò': 'o', 'ù': 'u'
  };
  
  return normalized.replace(/[áéíóúüñçàèìòù]/g, match => charMap[match] || match);
};

exports.registerStudent = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { firstName, middleName, lastName, email, studentNumber, courseName, courseId, yearLevel, gender, birthdate, password, createdBy } = req.body;

    const studentExists = await checkStudentNumberExists(studentNumber);
    if (studentExists) {
      return res.status(400).json({ message: "Student number already exists" });
    }

    let hashedPassword;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
    } else {
      const autoGeneratedPassword = generateStudentPassword(lastName, studentNumber);
      hashedPassword = await bcrypt.hash(autoGeneratedPassword, 10);
    }

    let processedMiddleName = null;
    if (middleName !== undefined && middleName !== null) {
      const middleNameStr = String(middleName).trim();
      if (middleNameStr.length > 0) {
        processedMiddleName = middleNameStr;
      }
    }

    let processedBirthdate = null;
    if (birthdate) {
      try {
        processedBirthdate = new Date(birthdate);
        if (isNaN(processedBirthdate.getTime())) {
          return res.status(400).json({ message: "Invalid birthdate format" });
        }
      } catch (error) {
        return res.status(400).json({ message: "Invalid birthdate format" });
      }
    }

    let studentEmail = email;
    if (!studentEmail) {

      const normalizedLastName = normalizeForEmail(lastName);
      const lastSixDigits = studentNumber.slice(-6);
      studentEmail = `${normalizedLastName}.${lastSixDigits}@novaliches.sti.edu.ph`;
    }

    const student = await registerStudent(
      firstName,
      processedMiddleName,
      lastName,
      studentEmail,
      studentEmail, 
      hashedPassword,
      studentNumber,
      courseName,
      yearLevel,
      gender,
      processedBirthdate,
      createdBy,
      courseId
    );

    res.status(201).json({
      success: true,
      message: "Student registered successfully",
      student,
    });
  } catch (error) {
    console.error("Registration Error:", error);
    
    let errorMessage = error.message;

    if (error.code === '23503' && error.constraint === 'students_course_name_fkey') {
      errorMessage = `The course '${req.body.courseName}' does not exist in the database. Please add it first or use a valid course.`;
    }
    
    res.status(500).json({
      message: "Failed to register student",
      error: errorMessage,
    });
  }
};

exports.getAllStudents = async (req, res) => {
  try {
    const students = await getAllStudents();
    res.status(200).json({ students });
  } catch (error) {
    console.error("Error fetching students:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.getStudentById = async (req, res) => {
  try {
    const studentId = req.params.id;
    const student = await getStudentById(studentId);

    if (!student) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ student });
  } catch (error) {
    console.error("Error fetching student by ID:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.editStudent = async (req, res) => {
  try {
    const studentId = req.params.id;
    const { firstName, middleName, lastName, courseName, yearLevel, gender, birthdate } = req.body;

    if (!firstName || !lastName || !courseName || !yearLevel || !gender) {
      return res.status(400).json({ message: "All required fields must be provided" });
    }

    const updatedStudent = await updateStudent(studentId, firstName, middleName, lastName, courseName, yearLevel, gender, birthdate ? new Date(birthdate) : null);

    if (!updatedStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student updated successfully", student: updatedStudent });
  } catch (error) {
    console.error("Error updating student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.deleteStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const deletedStudent = await softDeleteStudent(studentId);
    if (!deletedStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student deleted successfully (soft delete)", student: deletedStudent });
  } catch (error) {
    console.error("Error deleting student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.restoreStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const restoredStudent = await restoreStudent(studentId);
    if (!restoredStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student restored successfully", student: restoredStudent });
  } catch (error) {
    console.error("Error restoring student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.resetStudentPassword = async (req, res) => {
  try {
    const { studentId, newPassword } = req.body;

    if (!studentId || !newPassword) {
      return res.status(400).json({ message: "Student ID and new password are required." });
    }

    const passwordRegex = /^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    if (!passwordRegex.test(newPassword)) {
      return res.status(400).json({ message: "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character." });
    }

    const updatedStudent = await resetStudentPassword(studentId, newPassword);
    if (!updatedStudent) {
      return res.status(404).json({ message: "Student not found or not linked to a user." });
    }

    res.status(200).json({ message: "Student password reset successfully", student: updatedStudent });
  } catch (error) {
    console.error("Error resetting student password:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.permanentDeleteStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const deletedStudent = await deleteStudentPermanently(studentId);
    if (!deletedStudent) {
      return res.status(404).json({ message: "Student not found or already deleted permanently." });
    }

    res.status(200).json({ message: "Student permanently deleted." });
  } catch (error) {
    console.error("Error permanently deleting student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.unlockStudentAccount = async (req, res) => {
  try {
    const studentId = req.params.id;
    const unlockedAccount = await unlockStudentAccount(studentId);
    
    if (!unlockedAccount) {
      return res.status(404).json({ message: "Student not found" });
    }
    
    res.status(200).json({ message: "Student account unlocked successfully" });
  } catch (error) {
    console.error("Error unlocking student account:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.uploadStudentsBatch = async (req, res) => {
  try {
    console.log('=== BATCH UPLOAD DEBUG START ===');
    console.log('Environment:', process.env.NODE_ENV || 'development');
    console.log('XLSX library version:', XLSX.version);
    console.log('Request body:', req.body);
    console.log('File info:', req.file ? { 
      filename: req.file.filename, 
      originalname: req.file.originalname,
      size: req.file.size,
      path: req.file.path,
      mimetype: req.file.mimetype
    } : 'No file');
    
    // Basic request validation (express-validator removed, using route validation)
    console.log('Controller reached - basic validation passed');
    
    if (!req.file) {
      console.log('ERROR: No file uploaded');
      return res.status(400).json({ message: 'No file uploaded' });
    }
    if (!req.body.createdBy) {
      console.log('ERROR: No createdBy in request body');
      return res.status(400).json({ message: 'Super Admin ID is required' });
    }

    const filePath = path.resolve(req.file.path);
    
    if (!fs.existsSync(filePath)) {
      throw new Error('Uploaded file not found');
    }

    const fileBuffer = fs.readFileSync(filePath);
    console.log('File size:', fileBuffer.length, 'bytes');
    console.log('File stats:', fs.statSync(filePath));
    
    // Check if file is a valid Excel file by checking the header
    const fileHeader = fileBuffer.slice(0, 8);
    console.log('File header (hex):', fileHeader.toString('hex'));
    console.log('File header (string):', fileHeader.toString('ascii').replace(/[^\x20-\x7E]/g, '.'));
    
    // Try multiple parsing strategies
    let workbook, worksheet, jsonData = [];
    
    try {
      // Strategy 1: Default parsing
      workbook = XLSX.read(fileBuffer, { type: 'buffer' });
      worksheet = workbook.Sheets[workbook.SheetNames[0]];
      jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: '' });
      console.log('Strategy 1 (default) - Found', jsonData.length, 'rows');
      
      if (jsonData.length === 0) {
        throw new Error('No data found with default strategy');
      }
    } catch (error) {
      console.log('Strategy 1 failed:', error.message);
      
      try {
        // Strategy 2: Raw array parsing then convert to objects
        const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
        console.log('Strategy 2 (raw) - Found', rawData.length, 'rows');
        console.log('First 3 raw rows:', rawData.slice(0, 3));
        
        if (rawData.length < 2) {
          throw new Error('Not enough data rows');
        }
        
        // Use first row as headers
        const headers = rawData[0].map(h => h ? h.toString().trim() : '');
        const dataRows = rawData.slice(1);
        
        console.log('Headers found:', headers);
        
        jsonData = dataRows.map((row, index) => {
          const obj = {};
          headers.forEach((header, colIndex) => {
            if (header && row[colIndex] !== undefined && row[colIndex] !== null) {
              obj[header] = row[colIndex];
            }
          });
          return obj;
        });
        
        console.log('Strategy 2 converted', jsonData.length, 'data objects');
      } catch (error2) {
        console.log('Strategy 2 failed:', error2.message);
        
        try {
          // Strategy 3: Different reading options
          workbook = XLSX.read(fileBuffer, { 
            type: 'buffer',
            cellDates: true,
            cellNF: false,
            cellText: false
          });
          worksheet = workbook.Sheets[workbook.SheetNames[0]];
          jsonData = XLSX.utils.sheet_to_json(worksheet, { 
            header: 'A',
            defval: '',
            blankrows: false
          });
          console.log('Strategy 3 (alternative) - Found', jsonData.length, 'rows');
        } catch (error3) {
          console.log('Strategy 3 failed:', error3.message);
          
          // Strategy 4: Try reading as CSV if Excel parsing completely fails
          try {
            console.log('Strategy 4: Attempting CSV parsing as last resort...');
            const fileContent = fs.readFileSync(filePath, 'utf8');
            const lines = fileContent.split('\n').filter(line => line.trim());
            
            if (lines.length < 2) {
              throw new Error('Not enough lines in file');
            }
            
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            console.log('CSV headers:', headers);
            
            jsonData = lines.slice(1).map(line => {
              const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
              const obj = {};
              headers.forEach((header, index) => {
                if (header && values[index]) {
                  obj[header] = values[index];
                }
              });
              return obj;
            });
            
            console.log('Strategy 4 (CSV) - Found', jsonData.length, 'rows');
          } catch (error4) {
            console.log('Strategy 4 failed:', error4.message);
            throw new Error(`All parsing strategies failed. Original errors: Excel(${error.message}), Raw(${error2.message}), Alt(${error3.message}), CSV(${error4.message})`);
          }
        }
      }
    }

    if (jsonData.length === 0) {
      return res.status(400).json({ message: 'Excel file contains no data' });
    }

    // Debug: Log the first few raw records to see what we're getting
    console.log('Sample raw data from Excel:', JSON.stringify(jsonData.slice(0, 2), null, 2));
    
    // Debug: Show what headers we found
    if (jsonData.length > 0) {
      console.log('Excel headers found:', Object.keys(jsonData[0]));
    }

    console.log('Raw data sample (first 2 rows):', jsonData.slice(0, 2).map(row => {
      return Object.keys(row).reduce((acc, key) => {
        acc[key] = row[key];
        return acc;
      }, {});
    }));

    // Enhanced column mapping with better production handling
    jsonData = jsonData.map((row, index) => {
      const normalizedRow = {};
      let mappedFields = [];

      Object.keys(row).forEach(key => {
        // Clean up the key
        const originalKey = key.toString();
        const normalizedKey = originalKey.toLowerCase().replace(/[\s_-]+/g, '').trim();
        let originalValue = row[key];
        
        // Handle different value types that might come from Excel
        if (originalValue !== null && originalValue !== undefined) {
          originalValue = originalValue.toString().trim();
        }
        
        // Skip completely empty keys or values
        if (!originalKey || originalKey.trim() === '' || !originalValue) {
          return;
        }
      
        // Enhanced mapping with more variations
        let mapped = false;
        
        // First Name mapping
        if (!mapped && (normalizedKey === 'firstname' || normalizedKey === 'first' || normalizedKey === 'fname' || originalKey === 'firstName')) {
          normalizedRow.firstName = originalValue;
          mappedFields.push(`${originalKey} -> firstName`);
          mapped = true;
        }
        // Middle Name mapping  
        else if (!mapped && (normalizedKey === 'middlename' || normalizedKey === 'middle' || normalizedKey === 'mname' || originalKey === 'middleName')) {
          normalizedRow.middleName = originalValue;
          mappedFields.push(`${originalKey} -> middleName`);
          mapped = true;
        }
        // Last Name mapping
        else if (!mapped && (normalizedKey === 'lastname' || normalizedKey === 'last' || normalizedKey === 'lname' || originalKey === 'lastName')) {
          normalizedRow.lastName = originalValue;
          mappedFields.push(`${originalKey} -> lastName`);
          mapped = true;
        }
        // Student Number mapping
        else if (!mapped && (normalizedKey === 'studentnumber' || normalizedKey === 'studentno' || normalizedKey === 'idnumber' || normalizedKey === 'id' || normalizedKey === 'number' || originalKey === 'studentNumber')) {
          normalizedRow.studentNumber = originalValue;
          mappedFields.push(`${originalKey} -> studentNumber`);
          mapped = true;
        }
        // Course Name mapping
        else if (!mapped && (normalizedKey === 'coursename' || normalizedKey === 'course' || normalizedKey === 'program' || normalizedKey === 'strand' || originalKey === 'courseName')) {
          normalizedRow.courseName = originalValue;
          mappedFields.push(`${originalKey} -> courseName`);
          mapped = true;
        }
        // Year Level mapping
        else if (!mapped && (normalizedKey === 'yearlevel' || normalizedKey === 'year' || normalizedKey === 'level' || normalizedKey === 'grade' || originalKey === 'yearLevel')) {
          normalizedRow.yearLevel = originalValue;
          mappedFields.push(`${originalKey} -> yearLevel`);
          mapped = true;
        }
        // Gender mapping
        else if (!mapped && (normalizedKey === 'gender' || normalizedKey === 'sex')) {
          normalizedRow.gender = originalValue;
          mappedFields.push(`${originalKey} -> gender`);
          mapped = true;
        }
        // Birthdate mapping
        else if (!mapped && (normalizedKey === 'birthdate' || normalizedKey === 'birthday' || normalizedKey === 'dob' || normalizedKey === 'birth' || normalizedKey === 'dateofbirth')) {
          normalizedRow.birthdate = originalValue;
          mappedFields.push(`${originalKey} -> birthdate`);
          mapped = true;
        }
        // Email mapping
        else if (!mapped && (normalizedKey === 'email' || normalizedKey === 'emailaddress')) {
          normalizedRow.email = originalValue;
          mappedFields.push(`${originalKey} -> email`);
          mapped = true;
        }
        
        // If not mapped, keep original for debugging
        if (!mapped) {
          normalizedRow[originalKey] = originalValue;
        }
      });
      
      // Debug mapping for first few rows
      if (index < 3) {
        console.log(`Row ${index + 1} mappings:`, mappedFields);
        console.log(`Row ${index + 1} result:`, normalizedRow);
      }
      
      return normalizedRow;
    });
    const requiredFields = ['firstName', 'lastName', 'studentNumber', 'courseName', 'yearLevel', 'gender'];
    const invalidRows = [];
    const validatedData = [];
    
    // Filter out completely empty rows
    jsonData = jsonData.filter(row => {
      return Object.values(row).some(value => 
        value !== null && value !== undefined && String(value).trim() !== ''
      );
    });

    console.log(`Processing ${jsonData.length} non-empty rows`);

    jsonData.forEach((student, index) => {
      const missingFields = [];
      const rowNum = index + 2; 

      // Debug problematic rows
      if (index < 3) {
        console.log(`Row ${rowNum} data:`, JSON.stringify(student, null, 2));
      }

      requiredFields.forEach(field => {
        if (student[field] === undefined || student[field] === null || String(student[field]).trim() === '') {
          missingFields.push(field);
        }
      });
      
      if (missingFields.length > 0) {     
       invalidRows.push({
          row: rowNum,
          studentNumber: student.studentNumber || 'Unknown',
          firstName: student.firstName || 'Unknown',
          lastName: student.lastName || 'Unknown',
          error: `Missing required fields: ${missingFields.join(', ')}`
        });
      } else {
      
        if (student.studentNumber && !/^02000[0-9]{6}$/.test(student.studentNumber)) {
          invalidRows.push({
            row: rowNum,
            studentNumber: student.studentNumber,
            firstName: student.firstName || 'Unknown',
            lastName: student.lastName || 'Unknown',
            error: 'Invalid student number format. Must be 11 digits starting with 02000'
          });
          return; 
        }

        if (!student.email) {
          const normalizedLastName = normalizeForEmail(student.lastName);
          const lastSixDigits = student.studentNumber.slice(-6);
          student.email = `${normalizedLastName}.${lastSixDigits}@novaliches.sti.edu.ph`;      
        }

        if (student.yearLevel) {
          const yearLevelStr = String(student.yearLevel).trim();
          let year = null;

          const startsWithNumberMatch = yearLevelStr.match(/^(\d)/);
          if (startsWithNumberMatch) {
            year = parseInt(startsWithNumberMatch[1]);
          } 
          else if (yearLevelStr.toLowerCase().includes('first') || yearLevelStr.toLowerCase().includes('1st')) {
            year = 1;
          }
          else if (yearLevelStr.toLowerCase().includes('second') || yearLevelStr.toLowerCase().includes('2nd')) {
            year = 2;
          }
          else if (yearLevelStr.toLowerCase().includes('third') || yearLevelStr.toLowerCase().includes('3rd')) {
            year = 3;
          }
          else if (yearLevelStr.toLowerCase().includes('fourth') || yearLevelStr.toLowerCase().includes('4th')) {
            year = 4;
          }
          // Handle senior high school year levels
          else if (yearLevelStr.toLowerCase() === 'g11' || yearLevelStr.toLowerCase() === 'grade 11') {
            student.yearLevel = 'Grade 11';
            validatedData.push(student);
            return; // Skip the rest of the validation for year level
          }
          else if (yearLevelStr.toLowerCase() === 'g12' || yearLevelStr.toLowerCase() === 'grade 12') {
            student.yearLevel = 'Grade 12';
            validatedData.push(student);
            return; // Skip the rest of the validation for year level
          }

          if (year >= 1 && year <= 4) {
            const yearLevelMap = {
              1: "1st Year",
              2: "2nd Year",
              3: "3rd Year",
              4: "4th Year"
            };
            student.yearLevel = yearLevelMap[year];
          } else {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: `Invalid year level: "${yearLevelStr}". Must be 1st-4th Year, G11, G12, or contain a digit 1-4.`
            });
            return; 
          }
        }

        if (student.gender) {
          const normalizedGender = student.gender.toString().trim().toLowerCase();
          if (normalizedGender === 'male' || normalizedGender === 'm') {
            student.gender = 'Male'; 
          } else if (normalizedGender === 'female' || normalizedGender === 'f') {
            student.gender = 'Female'; 
          } else {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: 'Invalid gender. Must be either "Male" or "Female"'
            });
            return; 
          }
        }

        if (student.birthdate) {
          try {
            const date = new Date(student.birthdate);
            if (isNaN(date.getTime())) {
              invalidRows.push({
                row: rowNum,
                studentNumber: student.studentNumber,
                firstName: student.firstName || 'Unknown',
                lastName: student.lastName || 'Unknown',
                error: 'Invalid birthdate format'
              });
              return; 
            }
          } catch (e) {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: 'Invalid birthdate format'
            });
            return; 
          }
        }

        validatedData.push(student);
      }
    });
    
    console.log(`Found ${invalidRows.length} invalid rows and ${validatedData.length} valid rows`);
    
    if (validatedData.length === 0 && invalidRows.length > 0) {
      return res.status(400).json({
        message: 'All rows in the Excel file contain errors',
        errors: invalidRows
      });
    }

    const uniqueCourseNames = new Set();
    validatedData.forEach(student => {
      if (student.courseName) {
        uniqueCourseNames.add(student.courseName.trim());
      }
    });

    if (uniqueCourseNames.size > 0) {

      const existingCoursesResult = await pool.query(
        "SELECT course_name FROM courses"
      );
      const existingCourses = new Set(
        existingCoursesResult.rows.map(course => course.course_name.toLowerCase())
      );

      for (const courseName of uniqueCourseNames) {
        if (!existingCourses.has(courseName.toLowerCase())) {
          try {
            await pool.query(
              "INSERT INTO courses (course_name) VALUES ($1) ON CONFLICT DO NOTHING",
              [courseName]
            );
           
          } catch (error) {
            console.error(`Failed to add course ${courseName}:`, error);
          }
        }
      }
    }

    console.log(`Processing batch with ${validatedData.length} students`);
    const result = await processBatchStudents(validatedData, req.body.createdBy);

    try {
      fs.unlinkSync(filePath);
    } catch (unlinkError) {
      console.error('Error deleting temp file:', unlinkError);
    }

    const allErrors = [...invalidRows];
    if (result.errors && result.errors.length > 0) {
      allErrors.push(...result.errors);
    }

    res.status(200).json({
      message: 'Batch upload processed',
      total: jsonData.length,
      success: result.success,
      failed: invalidRows.length + result.failed,
      errors: allErrors
    });
  } catch (error) {
    console.error('=== BATCH UPLOAD ERROR ===');
    console.error('Error details:', error);
    console.error('Stack trace:', error.stack);
    
    // Provide more specific error messages
    let errorMessage = 'Error processing batch upload';
    let statusCode = 500;
    
    if (error.message.includes('No file uploaded')) {
      errorMessage = 'No file was uploaded. Please select an Excel file.';
      statusCode = 400;
    } else if (error.message.includes('Super Admin ID')) {
      errorMessage = 'Authentication error. Please log in again.';
      statusCode = 401;
    } else if (error.message.includes('Excel file contains no data')) {
      errorMessage = 'The Excel file appears to be empty or corrupted.';
      statusCode = 400;
    } else if (error.message.includes('Uploaded file not found')) {
      errorMessage = 'File upload failed. Please try again.';
      statusCode = 400;
    }
    
    res.status(statusCode).json({ 
      message: errorMessage,
      error: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

exports.getStudentElections = async (req, res) => {
  try {
   
    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
    
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
  
    let studentResult;
    
    try {
 
      if (studentId) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE id = $1 AND is_active = TRUE
        `, [studentId]);
      }
      

      if (!studentId || studentResult.rows.length === 0) {
        studentResult = await pool.query(`
          SELECT s.id 
          FROM students s
          JOIN users u ON s.email = u.email
          WHERE u.id = $1 AND s.is_active = TRUE
        `, [userId]);
      }
      
      if (studentResult.rows.length === 0) {
        return res.status(404).json({ message: "Student record not found for this user" });
      }
      
      const actualStudentId = studentResult.rows[0].id;
      const elections = await pool.query(`
        SELECT 
          e.id, e.title, e.description, 
          e.date_from, e.date_to,
          e.start_time, e.end_time,
          e.status,
          ev.has_voted,
          (SELECT COUNT(*) FROM eligible_voters WHERE election_id = e.id) AS voter_count,
          (SELECT COUNT(*) FROM eligible_voters WHERE election_id = e.id AND has_voted = TRUE) AS vote_count,
          EXISTS (
            SELECT 1 FROM ballots b 
            WHERE b.election_id = e.id
          ) AS ballot_exists,
          CASE
            WHEN EXISTS (
              SELECT 1 FROM users u 
              WHERE u.id = e.created_by 
              AND u.role_id = 1
            ) THEN TRUE
            ELSE e.needs_approval = FALSE OR e.status = 'approved'
          END as is_available
        FROM elections e
        INNER JOIN eligible_voters ev ON e.id = ev.election_id
        WHERE ev.student_id = $1
        AND e.status != 'draft'
        AND (
          (e.needs_approval = FALSE AND e.status != 'draft')
          OR 
          (e.status = 'approved' AND e.needs_approval = TRUE)
          OR
          EXISTS (
            SELECT 1 FROM users u 
            WHERE u.id = e.created_by 
            AND u.role_id = 1
          )
        )
        ORDER BY 
          CASE 
            WHEN e.status = 'ongoing' THEN 1
            WHEN e.status = 'upcoming' THEN 2
            ELSE 3
          END, 
          e.date_from
      `, [actualStudentId]);
      

      const result = elections.rows.map(election => ({
        ...election,
        has_voted: election.has_voted
      }));
      
      return res.json(result);
      
    } catch (err) {
      console.error("Database error in getStudentElections:", err);
      return res.status(500).json({ error: 'Database error: ' + err.message });
    }
  } catch (err) {
    console.error("General error in getStudentElections:", err);
    return res.status(500).json({ error: 'Failed to fetch elections: ' + err.message });
  }
};

exports.getStudentProfile = async (req, res) => {
  try {

    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }  
    let result;
    
    try {

      if (studentId) {
        result = await pool.query(`
          SELECT 
            s.id, 
            s.first_name AS "firstName", 
            s.middle_name AS "middleName",
            s.last_name AS "lastName", 
            s.email, 
            s.student_number AS "studentNumber", 
            s.course_name AS "courseName", 
            s.year_level AS "yearLevel", 
            s.gender,
            s.birthdate,
            s.profile_picture,
            COUNT(DISTINCT ev.election_id) AS "totalEligibleElections",
            SUM(CASE WHEN ev.has_voted = TRUE THEN 1 ELSE 0 END) AS "votedElections"
          FROM students s
          LEFT JOIN eligible_voters ev ON s.id = ev.student_id
          WHERE s.id = $1 AND s.is_active = TRUE
          GROUP BY s.id
        `, [studentId]);
      }
      
 
      if (!studentId || result.rows.length === 0) {
        result = await pool.query(`
          SELECT 
            s.id, 
            s.first_name AS "firstName", 
            s.middle_name AS "middleName",
            s.last_name AS "lastName", 
            s.email, 
            s.student_number AS "studentNumber", 
            s.course_name AS "courseName", 
            s.year_level AS "yearLevel", 
            s.gender,
            s.birthdate,
            s.profile_picture,
            COUNT(DISTINCT ev.election_id) AS "totalEligibleElections",
            SUM(CASE WHEN ev.has_voted = TRUE THEN 1 ELSE 0 END) AS "votedElections"
          FROM students s
          LEFT JOIN eligible_voters ev ON s.id = ev.student_id
          WHERE s.user_id = $1 AND s.is_active = TRUE
          GROUP BY s.id
        `, [userId]);
      }
      
      if (result.rows.length === 0) {
        return res.status(404).json({ message: "Student profile not found" });
      }

      const profile = result.rows[0];
      if (profile.profile_picture) {
        // Return absolute URL for production, relative for development
        const baseUrl = process.env.NODE_ENV === 'production' 
          ? (req.protocol + '://' + req.get('host'))
          : '';
        profile.profile_picture = `${baseUrl}/uploads/profiles/${profile.profile_picture}`;
      }

      return res.status(200).json(profile);
      
    } catch (err) {
      console.error("Database error in getStudentProfile:", err);
      return res.status(500).json({ message: "Database error: " + err.message });
    }
  } catch (error) {
    console.error("General error in getStudentProfile:", error);
    return res.status(500).json({ message: "Failed to fetch student profile: " + error.message });
  }
};

exports.uploadProfilePicture = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }
    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
  
    let studentResult;
    
    try {
    
      if (studentId) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE id = $1 AND is_active = TRUE
        `, [studentId]);
      }
      
      if (!studentId || studentResult.rows.length === 0) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE user_id = $1 AND is_active = TRUE
        `, [userId]);
      }
      
      if (studentResult.rows.length === 0) {
        return res.status(404).json({ message: "Student record not found for this user" });
      }
      
      const actualStudentId = studentResult.rows[0].id;
      
      await pool.query(`
        UPDATE students 
        SET profile_picture = $1 
        WHERE id = $2
      `, [req.file.filename, actualStudentId]);
      
      // Return absolute URL for production, relative for development
      const baseUrl = process.env.NODE_ENV === 'production' 
        ? (req.protocol + '://' + req.get('host'))
        : '';
      const filePath = `${baseUrl}/uploads/profiles/${req.file.filename}`;
      
      return res.json({ success: true, filePath });
    } catch (err) {
      console.error("Database error in uploadProfilePicture:", err);
      return res.status(500).json({ message: "Database error: " + err.message });
    }
  } catch (error) {
    console.error("Error uploading file:", error);
    return res.status(500).json({ message: "Server error", error });
  }
};

exports.getStudentsByCourses = async (req, res) => {
  try {
   
    const { courses } = req.query;
    
    if (!courses) {
      return res.status(400).json({ success: false, message: "Courses parameter is required" });
    }

    const courseList = courses.split(',').map(course => course.trim());
    
    if (courseList.length === 0) {
      return res.status(400).json({ success: false, message: "At least one course must be provided" });
    }

    const courseRegex = /^[a-zA-Z0-9\s\-_.,()]{1,100}$/;
    for (const course of courseList) {
      if (!courseRegex.test(course)) {
        return res.status(400).json({ 
          success: false, 
          message: `Invalid course name format: ${course}. Only alphanumeric characters, spaces, and common punctuation are allowed.` 
        });
      }
    }
  
    let query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.middle_name,
        s.last_name, 
        s.email, 
        s.student_number, 
        s.course_name, 
        s.year_level, 
        s.gender, 
        s.birthdate,
        s.is_active,
        u.is_locked,
        u.locked_until
      FROM students s
      JOIN users u ON s.user_id = u.id
      WHERE s.course_name IN (`;

    const placeholders = courseList.map((_, index) => `$${index + 1}`).join(',');
    query += `${placeholders}) ORDER BY s.last_name ASC`;
    
    const result = await pool.query(query, courseList);
    
    return res.status(200).json(result.rows);
  } catch (error) {
    console.error("Error fetching students by courses:", error);
    return res.status(500).json({ 
      success: false, 
      message: "Failed to fetch students by courses",
      error: error.message 
    });
  }
};

exports.validateStudentByNumber = async (req, res) => {
  try {
    const { studentNumber } = req.query;
 
    
    if (!studentNumber) {
      return res.status(400).json({ 
        success: false, 
        message: "Student number is required" 
      });
    }
    
    // Validate student number format
    if (!/^02000[0-9]{6}$/.test(studentNumber)) {

      return res.status(400).json({
        success: false,
        message: "Invalid student number format. Must be 11 digits starting with 02000"
      });
    }
    
    // Query to find the student
    const query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.last_name, 
        s.student_number, 
        s.course_name,
        s.year_level,
        s.is_active
      FROM students s
      WHERE s.student_number = $1 AND s.is_active = TRUE
    `;
    
    const result = await pool.query(query, [studentNumber]);
    console.log(`Query results for ${studentNumber}:`, result.rows);
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Student not found or inactive"
      });
    }
    
    return res.status(200).json({
      success: true,
      student: result.rows[0]
    });
  } catch (error) {
    console.error("Error validating student:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to validate student",
      error: error.message
    });
  }
};

exports.searchStudents = async (req, res) => {
  try {
    const { term } = req.query;
    console.log(`Searching for students with term: ${term}`);
    
    if (!term || term.length < 4) {
      return res.status(400).json({ 
        success: false, 
        message: "Search term must be at least 4 characters" 
      });
    }
    
    // Search by student number (partial match)
    const query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.last_name, 
        s.student_number, 
        s.course_name
      FROM students s
      WHERE s.student_number LIKE $1 AND s.is_active = TRUE
      ORDER BY s.student_number
      LIMIT 10
    `;
    
    const searchTerm = `%${term}%`;
    const result = await pool.query(query, [searchTerm]);
    console.log(`Search results for "${term}":`, result.rows);
    
    return res.status(200).json({
      success: true,
      students: result.rows
    });
  } catch (error) {
    console.error("Error searching students:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to search students",
      error: error.message
    });
  }
};

exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    const userId = req.user.id;


    if (!currentPassword || !newPassword) {
      return res.status(400).json({ message: "Current password and new password are required" });
    }

    const passwordRegex = /^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    if (!passwordRegex.test(newPassword)) {
      console.log("Password validation failed");
      return res.status(400).json({ 
        message: "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character." 
      });
    }

    try {
 
      const result = await changePassword(userId, currentPassword, newPassword);
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error in changePassword model:", error);
      if (error.message === "Current password is incorrect") {
        return res.status(401).json({ message: error.message });
      }
      if (error.message === "User not found") {
        return res.status(404).json({ message: error.message });
      }
      throw error; 
    }
  } catch (error) {
    console.error("Error in changePassword controller:", error);
    res.status(500).json({ 
      message: "Error changing password",
      error: error.message 
    });
  }
};

// Bulk delete students by course (archive)
exports.bulkDeleteStudentsByCourse = async (req, res) => {
  try {
    const { courseName } = req.body;

    if (!courseName) {
      return res.status(400).json({
        success: false,
        message: "Course name is required"
      });
    }

    const result = await bulkDeleteStudentsByCourse(courseName, false);

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.status(200).json({
      success: true,
      message: result.message,
      deletedCount: result.deletedCount,
      students: result.students
    });
  } catch (error) {
    console.error("Error in bulkDeleteStudentsByCourse controller:", error);
    res.status(500).json({
      success: false,
      message: "Error archiving students by course",
      error: error.message
    });
  }
};

// Bulk permanent delete students by course
exports.bulkPermanentDeleteStudentsByCourse = async (req, res) => {
  try {
    const { courseName } = req.body;

    if (!courseName) {
      return res.status(400).json({
        success: false,
        message: "Course name is required"
      });
    }

    const result = await bulkDeleteStudentsByCourse(courseName, true);

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.status(200).json({
      success: true,
      message: result.message,
      deletedCount: result.deletedCount,
      students: result.students
    });
  } catch (error) {
    console.error("Error in bulkPermanentDeleteStudentsByCourse controller:", error);
    res.status(500).json({
      success: false,
      message: "Error permanently deleting students by course",
      error: error.message
    });
  }
};

// Bulk permanent delete archived students by course
exports.bulkDeleteArchivedStudentsByCourse = async (req, res) => {
  try {
    const { courseName } = req.body;

    if (!courseName) {
      return res.status(400).json({
        success: false,
        message: "Course name is required"
      });
    }

    const result = await bulkDeleteArchivedStudentsByCourse(courseName);

    if (!result.success) {
      return res.status(404).json(result);
    }

    res.status(200).json({
      success: true,
      message: result.message,
      deletedCount: result.deletedCount,
      students: result.students
    });
  } catch (error) {
    console.error("Error in bulkDeleteArchivedStudentsByCourse controller:", error);
    res.status(500).json({
      success: false,
      message: "Error permanently deleting archived students by course",
      error: error.message
    });
  }
};
