const bcrypt = require("bcryptjs");
const { validationResult } = require("express-validator");
const { checkStudentNumberExists, registerStudent, getAllStudents, getStudentById, updateStudent, softDeleteStudent, restoreStudent, resetStudentPassword, deleteStudentPermanently, unlockStudentAccount, processBatchStudents, changePassword } = require("../models/studentModel");
const XLSX = require('xlsx');
const fs = require('fs');
const path = require('path');
const pool = require("../config/db");


const generateStudentPassword = (lastName, studentNumber) => {
  const lastThreeDigits = studentNumber.slice(-3);
  const specialCharacter = "!";
  return `${lastName}${lastThreeDigits}${specialCharacter}`;
}

const isValidStudentEmail = (email, studentNumber, lastName) => {
  const lastSixDigits = studentNumber.slice(-6); 
  const expectedEmail = `${lastName.toLowerCase()}.${lastSixDigits}@novaliches.sti.edu.ph`;
  return email.toLowerCase() === expectedEmail;
};

const normalizeForEmail = (text) => {
  if (!text) return '';

  let normalized = text.toLowerCase().replace(/\s+/g, '');
  
  // Replace Spanish characters with their ASCII equivalents
  const charMap = {
    'á': 'a', 'é': 'e', 'í': 'i', 'ó': 'o', 'ú': 'u',
    'ü': 'u', 'ñ': 'n', 'ç': 'c', 'à': 'a', 'è': 'e',
    'ì': 'i', 'ò': 'o', 'ù': 'u'
  };
  
  return normalized.replace(/[áéíóúüñçàèìòù]/g, match => charMap[match] || match);
};

exports.registerStudent = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { firstName, middleName, lastName, email, studentNumber, courseName, courseId, yearLevel, gender, birthdate, password, createdBy } = req.body;

    const studentExists = await checkStudentNumberExists(studentNumber);
    if (studentExists) {
      return res.status(400).json({ message: "Student number already exists" });
    }

    let hashedPassword;
    if (password) {
      hashedPassword = await bcrypt.hash(password, 10);
    } else {
      const autoGeneratedPassword = generateStudentPassword(lastName, studentNumber);
      hashedPassword = await bcrypt.hash(autoGeneratedPassword, 10);
    }

    let processedMiddleName = null;
    if (middleName !== undefined && middleName !== null) {
      const middleNameStr = String(middleName).trim();
      if (middleNameStr.length > 0) {
        processedMiddleName = middleNameStr;
      }
    }

    let processedBirthdate = null;
    if (birthdate) {
      try {
        processedBirthdate = new Date(birthdate);
        if (isNaN(processedBirthdate.getTime())) {
          return res.status(400).json({ message: "Invalid birthdate format" });
        }
      } catch (error) {
        return res.status(400).json({ message: "Invalid birthdate format" });
      }
    }

    let studentEmail = email;
    if (!studentEmail) {

      const normalizedLastName = normalizeForEmail(lastName);
      const lastSixDigits = studentNumber.slice(-6);
      studentEmail = `${normalizedLastName}.${lastSixDigits}@novaliches.sti.edu.ph`;
    }

    const student = await registerStudent(
      firstName,
      processedMiddleName,
      lastName,
      studentEmail,
      studentEmail, 
      hashedPassword,
      studentNumber,
      courseName,
      yearLevel,
      gender,
      processedBirthdate,
      createdBy,
      courseId
    );

    res.status(201).json({
      success: true,
      message: "Student registered successfully",
      student,
    });
  } catch (error) {
    console.error("Registration Error:", error);
    
    let errorMessage = error.message;

    if (error.code === '23503' && error.constraint === 'students_course_name_fkey') {
      errorMessage = `The course '${req.body.courseName}' does not exist in the database. Please add it first or use a valid course.`;
    }
    
    res.status(500).json({
      message: "Failed to register student",
      error: errorMessage,
    });
  }
};

exports.getAllStudents = async (req, res) => {
  try {
    const students = await getAllStudents();
    res.status(200).json({ students });
  } catch (error) {
    console.error("Error fetching students:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.getStudentById = async (req, res) => {
  try {
    const studentId = req.params.id;
    const student = await getStudentById(studentId);

    if (!student) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ student });
  } catch (error) {
    console.error("Error fetching student by ID:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.editStudent = async (req, res) => {
  try {
    const studentId = req.params.id;
    const { firstName, middleName, lastName, courseName, yearLevel, gender, birthdate } = req.body;

    if (!firstName || !lastName || !courseName || !yearLevel || !gender) {
      return res.status(400).json({ message: "All required fields must be provided" });
    }

    const updatedStudent = await updateStudent(studentId, firstName, middleName, lastName, courseName, yearLevel, gender, birthdate ? new Date(birthdate) : null);

    if (!updatedStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student updated successfully", student: updatedStudent });
  } catch (error) {
    console.error("Error updating student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.deleteStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const deletedStudent = await softDeleteStudent(studentId);
    if (!deletedStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student deleted successfully (soft delete)", student: deletedStudent });
  } catch (error) {
    console.error("Error deleting student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.restoreStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const restoredStudent = await restoreStudent(studentId);
    if (!restoredStudent) {
      return res.status(404).json({ message: "Student not found" });
    }

    res.status(200).json({ message: "Student restored successfully", student: restoredStudent });
  } catch (error) {
    console.error("Error restoring student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.resetStudentPassword = async (req, res) => {
  try {
    const { studentId, newPassword } = req.body;

    if (!studentId || !newPassword) {
      return res.status(400).json({ message: "Student ID and new password are required." });
    }

    const passwordRegex = /^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    if (!passwordRegex.test(newPassword)) {
      return res.status(400).json({ message: "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character." });
    }

    const updatedStudent = await resetStudentPassword(studentId, newPassword);
    if (!updatedStudent) {
      return res.status(404).json({ message: "Student not found or not linked to a user." });
    }

    res.status(200).json({ message: "Student password reset successfully", student: updatedStudent });
  } catch (error) {
    console.error("Error resetting student password:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.permanentDeleteStudent = async (req, res) => {
  try {
    const studentId = req.params.id;

    const deletedStudent = await deleteStudentPermanently(studentId);
    if (!deletedStudent) {
      return res.status(404).json({ message: "Student not found or already deleted permanently." });
    }

    res.status(200).json({ message: "Student permanently deleted." });
  } catch (error) {
    console.error("Error permanently deleting student:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.unlockStudentAccount = async (req, res) => {
  try {
    const studentId = req.params.id;
    const unlockedAccount = await unlockStudentAccount(studentId);
    
    if (!unlockedAccount) {
      return res.status(404).json({ message: "Student not found" });
    }
    
    res.status(200).json({ message: "Student account unlocked successfully" });
  } catch (error) {
    console.error("Error unlocking student account:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
};

exports.uploadStudentsBatch = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
    if (!req.body.createdBy) {
      return res.status(400).json({ message: 'Super Admin ID is required' });
    }

    const filePath = path.resolve(req.file.path);
    
    if (!fs.existsSync(filePath)) {
      throw new Error('Uploaded file not found');
    }

    const workbook = XLSX.read(fs.readFileSync(filePath));
    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
    let jsonData = XLSX.utils.sheet_to_json(worksheet);

    if (jsonData.length === 0) {
      return res.status(400).json({ message: 'Excel file contains no data' });
    }

    jsonData = jsonData.map(row => {
      const normalizedRow = {};

      Object.keys(row).forEach(key => {

        const normalizedKey = key.toLowerCase().replace(/\s+/g, '');
      
        // Map various possible column names to our expected format
        if (normalizedKey === 'firstname' || normalizedKey === 'first' || normalizedKey === 'fname') {
          normalizedRow.firstName = row[key];
        } else if (normalizedKey === 'middlename' || normalizedKey === 'middle' || normalizedKey === 'mname') {
          normalizedRow.middleName = row[key];
        } else if (normalizedKey === 'lastname' || normalizedKey === 'last' || normalizedKey === 'lname') {
          normalizedRow.lastName = row[key];
        } else if (normalizedKey === 'studentnumber' || normalizedKey === 'studentno' || normalizedKey === 'idnumber' || normalizedKey === 'id') {
          normalizedRow.studentNumber = String(row[key]); // Ensure it's a string
        } else if (normalizedKey === 'coursename' || normalizedKey === 'course' || normalizedKey === 'program') {
          normalizedRow.courseName = row[key];
        } else if (normalizedKey === 'yearlevel' || normalizedKey === 'year' || normalizedKey === 'level') {
          normalizedRow.yearLevel = row[key];
        } else if (normalizedKey === 'gender' || normalizedKey === 'sex') {
          normalizedRow.gender = row[key];
        } else if (normalizedKey === 'birthdate' || normalizedKey === 'birthday' || normalizedKey === 'dob' || normalizedKey === 'birth') {
          normalizedRow.birthdate = row[key];
        } else if (normalizedKey === 'email') {
          normalizedRow.email = row[key];
        } else {
          normalizedRow[key] = row[key];
        }
      });
      
      return normalizedRow;
    });
    const requiredFields = ['firstName', 'lastName', 'studentNumber', 'courseName', 'yearLevel', 'gender'];
    const invalidRows = [];
    const validatedData = [];
    
    jsonData.forEach((student, index) => {
      const missingFields = [];
      const rowNum = index + 2; 

      requiredFields.forEach(field => {
        if (student[field] === undefined || student[field] === null || String(student[field]).trim() === '') {
          missingFields.push(field);
        }
      });
      
      if (missingFields.length > 0) {     
       invalidRows.push({
          row: rowNum,
          studentNumber: student.studentNumber || 'Unknown',
          firstName: student.firstName || 'Unknown',
          lastName: student.lastName || 'Unknown',
          error: `Missing required fields: ${missingFields.join(', ')}`
        });
      } else {
      
        if (student.studentNumber && !/^02000[0-9]{6}$/.test(student.studentNumber)) {
          invalidRows.push({
            row: rowNum,
            studentNumber: student.studentNumber,
            firstName: student.firstName || 'Unknown',
            lastName: student.lastName || 'Unknown',
            error: 'Invalid student number format. Must be 11 digits starting with 02000'
          });
          return; 
        }

        if (!student.email) {
          const normalizedLastName = normalizeForEmail(student.lastName);
          const lastSixDigits = student.studentNumber.slice(-6);
          student.email = `${normalizedLastName}.${lastSixDigits}@novaliches.sti.edu.ph`;      
        }

        if (student.yearLevel) {
          const yearLevelStr = String(student.yearLevel).trim();
          let year = null;

          const startsWithNumberMatch = yearLevelStr.match(/^(\d)/);
          if (startsWithNumberMatch) {
            year = parseInt(startsWithNumberMatch[1]);
          } 
          else if (yearLevelStr.toLowerCase().includes('first') || yearLevelStr.toLowerCase().includes('1st')) {
            year = 1;
          }
          else if (yearLevelStr.toLowerCase().includes('second') || yearLevelStr.toLowerCase().includes('2nd')) {
            year = 2;
          }
          else if (yearLevelStr.toLowerCase().includes('third') || yearLevelStr.toLowerCase().includes('3rd')) {
            year = 3;
          }
          else if (yearLevelStr.toLowerCase().includes('fourth') || yearLevelStr.toLowerCase().includes('4th')) {
            year = 4;
          }
          // Handle senior high school year levels
          else if (yearLevelStr.toLowerCase() === 'g11' || yearLevelStr.toLowerCase() === 'grade 11') {
            student.yearLevel = 'Grade 11';
            validatedData.push(student);
            return; // Skip the rest of the validation for year level
          }
          else if (yearLevelStr.toLowerCase() === 'g12' || yearLevelStr.toLowerCase() === 'grade 12') {
            student.yearLevel = 'Grade 12';
            validatedData.push(student);
            return; // Skip the rest of the validation for year level
          }

          if (year >= 1 && year <= 4) {
            const yearLevelMap = {
              1: "1st Year",
              2: "2nd Year",
              3: "3rd Year",
              4: "4th Year"
            };
            student.yearLevel = yearLevelMap[year];
          } else {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: `Invalid year level: "${yearLevelStr}". Must be 1st-4th Year, G11, G12, or contain a digit 1-4.`
            });
            return; 
          }
        }

        if (student.gender) {
          const normalizedGender = student.gender.toString().trim().toLowerCase();
          if (normalizedGender === 'male' || normalizedGender === 'm') {
            student.gender = 'Male'; 
          } else if (normalizedGender === 'female' || normalizedGender === 'f') {
            student.gender = 'Female'; 
          } else {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: 'Invalid gender. Must be either "Male" or "Female"'
            });
            return; 
          }
        }

        if (student.birthdate) {
          try {
            const date = new Date(student.birthdate);
            if (isNaN(date.getTime())) {
              invalidRows.push({
                row: rowNum,
                studentNumber: student.studentNumber,
                firstName: student.firstName || 'Unknown',
                lastName: student.lastName || 'Unknown',
                error: 'Invalid birthdate format'
              });
              return; 
            }
          } catch (e) {
            invalidRows.push({
              row: rowNum,
              studentNumber: student.studentNumber,
              firstName: student.firstName || 'Unknown',
              lastName: student.lastName || 'Unknown',
              error: 'Invalid birthdate format'
            });
            return; 
          }
        }

        validatedData.push(student);
      }
    });
    
    console.log(`Found ${invalidRows.length} invalid rows and ${validatedData.length} valid rows`);
    
    if (validatedData.length === 0 && invalidRows.length > 0) {
      return res.status(400).json({
        message: 'All rows in the Excel file contain errors',
        errors: invalidRows
      });
    }

    const uniqueCourseNames = new Set();
    validatedData.forEach(student => {
      if (student.courseName) {
        uniqueCourseNames.add(student.courseName.trim());
      }
    });

    if (uniqueCourseNames.size > 0) {

      const existingCoursesResult = await pool.query(
        "SELECT course_name FROM courses"
      );
      const existingCourses = new Set(
        existingCoursesResult.rows.map(course => course.course_name.toLowerCase())
      );

      for (const courseName of uniqueCourseNames) {
        if (!existingCourses.has(courseName.toLowerCase())) {
          try {
            await pool.query(
              "INSERT INTO courses (course_name) VALUES ($1) ON CONFLICT DO NOTHING",
              [courseName]
            );
           
          } catch (error) {
            console.error(`Failed to add course ${courseName}:`, error);
          }
        }
      }
    }

    console.log(`Processing batch with ${validatedData.length} students`);
    const result = await processBatchStudents(validatedData, req.body.createdBy);

    try {
      fs.unlinkSync(filePath);
    } catch (unlinkError) {
      console.error('Error deleting temp file:', unlinkError);
    }

    const allErrors = [...invalidRows];
    if (result.errors && result.errors.length > 0) {
      allErrors.push(...result.errors);
    }

    res.status(200).json({
      message: 'Batch upload processed',
      total: jsonData.length,
      success: result.success,
      failed: invalidRows.length + result.failed,
      errors: allErrors
    });
  } catch (error) {
    console.error('Error processing batch upload:', error);
    res.status(500).json({ 
      message: 'Error processing batch upload',
      error: error.message,
      stack: error.stack 
    });
  }
};

exports.getStudentElections = async (req, res) => {
  try {
   
    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
    
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
  
    let studentResult;
    
    try {
 
      if (studentId) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE id = $1 AND is_active = TRUE
        `, [studentId]);
      }
      

      if (!studentId || studentResult.rows.length === 0) {
        studentResult = await pool.query(`
          SELECT s.id 
          FROM students s
          JOIN users u ON s.email = u.email
          WHERE u.id = $1 AND s.is_active = TRUE
        `, [userId]);
      }
      
      if (studentResult.rows.length === 0) {
        return res.status(404).json({ message: "Student record not found for this user" });
      }
      
      const actualStudentId = studentResult.rows[0].id;
      const elections = await pool.query(`
        SELECT 
          e.id, e.title, e.description, 
          e.date_from, e.date_to,
          e.start_time, e.end_time,
          e.status,
          ev.has_voted,
          (SELECT COUNT(*) FROM eligible_voters WHERE election_id = e.id) AS voter_count,
          (SELECT COUNT(*) FROM eligible_voters WHERE election_id = e.id AND has_voted = TRUE) AS vote_count,
          EXISTS (
            SELECT 1 FROM ballots b 
            WHERE b.election_id = e.id
          ) AS ballot_exists,
          CASE
            WHEN EXISTS (
              SELECT 1 FROM users u 
              WHERE u.id = e.created_by 
              AND u.role_id = 1
            ) THEN TRUE
            ELSE e.needs_approval = FALSE OR e.status = 'approved'
          END as is_available
        FROM elections e
        INNER JOIN eligible_voters ev ON e.id = ev.election_id
        WHERE ev.student_id = $1
        AND e.status != 'draft'
        AND (
          (e.needs_approval = FALSE AND e.status != 'draft')
          OR 
          (e.status = 'approved' AND e.needs_approval = TRUE)
          OR
          EXISTS (
            SELECT 1 FROM users u 
            WHERE u.id = e.created_by 
            AND u.role_id = 1
          )
        )
        ORDER BY 
          CASE 
            WHEN e.status = 'ongoing' THEN 1
            WHEN e.status = 'upcoming' THEN 2
            ELSE 3
          END, 
          e.date_from
      `, [actualStudentId]);
      

      const result = elections.rows.map(election => ({
        ...election,
        has_voted: election.has_voted
      }));
      
      return res.json(result);
      
    } catch (err) {
      console.error("Database error in getStudentElections:", err);
      return res.status(500).json({ error: 'Database error: ' + err.message });
    }
  } catch (err) {
    console.error("General error in getStudentElections:", err);
    return res.status(500).json({ error: 'Failed to fetch elections: ' + err.message });
  }
};

exports.getStudentProfile = async (req, res) => {
  try {

    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }  
    let result;
    
    try {

      if (studentId) {
        result = await pool.query(`
          SELECT 
            s.id, 
            s.first_name AS "firstName", 
            s.middle_name AS "middleName",
            s.last_name AS "lastName", 
            s.email, 
            s.student_number AS "studentNumber", 
            s.course_name AS "courseName", 
            s.year_level AS "yearLevel", 
            s.gender,
            s.birthdate,
            s.profile_picture,
            COUNT(DISTINCT ev.election_id) AS "totalEligibleElections",
            SUM(CASE WHEN ev.has_voted = TRUE THEN 1 ELSE 0 END) AS "votedElections"
          FROM students s
          LEFT JOIN eligible_voters ev ON s.id = ev.student_id
          WHERE s.id = $1 AND s.is_active = TRUE
          GROUP BY s.id
        `, [studentId]);
      }
      
 
      if (!studentId || result.rows.length === 0) {
        result = await pool.query(`
          SELECT 
            s.id, 
            s.first_name AS "firstName", 
            s.middle_name AS "middleName",
            s.last_name AS "lastName", 
            s.email, 
            s.student_number AS "studentNumber", 
            s.course_name AS "courseName", 
            s.year_level AS "yearLevel", 
            s.gender,
            s.birthdate,
            s.profile_picture,
            COUNT(DISTINCT ev.election_id) AS "totalEligibleElections",
            SUM(CASE WHEN ev.has_voted = TRUE THEN 1 ELSE 0 END) AS "votedElections"
          FROM students s
          LEFT JOIN eligible_voters ev ON s.id = ev.student_id
          WHERE s.user_id = $1 AND s.is_active = TRUE
          GROUP BY s.id
        `, [userId]);
      }
      
      if (result.rows.length === 0) {
        return res.status(404).json({ message: "Student profile not found" });
      }

      const profile = result.rows[0];
      if (profile.profile_picture) {
        // Return absolute URL for production, relative for development
        const baseUrl = process.env.NODE_ENV === 'production' 
          ? (req.protocol + '://' + req.get('host'))
          : '';
        profile.profile_picture = `${baseUrl}/uploads/profiles/${profile.profile_picture}`;
      }

      return res.status(200).json(profile);
      
    } catch (err) {
      console.error("Database error in getStudentProfile:", err);
      return res.status(500).json({ message: "Database error: " + err.message });
    }
  } catch (error) {
    console.error("General error in getStudentProfile:", error);
    return res.status(500).json({ message: "Failed to fetch student profile: " + error.message });
  }
};

exports.uploadProfilePicture = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }
    const userId = req.user.id;
    const studentId = req.user.studentId;
    
    if (!userId) {
      return res.status(401).json({ message: "Authentication required. User ID not found in token." });
    }
  
    let studentResult;
    
    try {
    
      if (studentId) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE id = $1 AND is_active = TRUE
        `, [studentId]);
      }
      
      if (!studentId || studentResult.rows.length === 0) {
        studentResult = await pool.query(`
          SELECT id FROM students WHERE user_id = $1 AND is_active = TRUE
        `, [userId]);
      }
      
      if (studentResult.rows.length === 0) {
        return res.status(404).json({ message: "Student record not found for this user" });
      }
      
      const actualStudentId = studentResult.rows[0].id;
      
      await pool.query(`
        UPDATE students 
        SET profile_picture = $1 
        WHERE id = $2
      `, [req.file.filename, actualStudentId]);
      
      // Return absolute URL for production, relative for development
      const baseUrl = process.env.NODE_ENV === 'production' 
        ? (req.protocol + '://' + req.get('host'))
        : '';
      const filePath = `${baseUrl}/uploads/profiles/${req.file.filename}`;
      
      return res.json({ success: true, filePath });
    } catch (err) {
      console.error("Database error in uploadProfilePicture:", err);
      return res.status(500).json({ message: "Database error: " + err.message });
    }
  } catch (error) {
    console.error("Error uploading file:", error);
    return res.status(500).json({ message: "Server error", error });
  }
};

exports.getStudentsByCourses = async (req, res) => {
  try {
   
    const { courses } = req.query;
    
    if (!courses) {
      return res.status(400).json({ success: false, message: "Courses parameter is required" });
    }

    const courseList = courses.split(',').map(course => course.trim());
    
    if (courseList.length === 0) {
      return res.status(400).json({ success: false, message: "At least one course must be provided" });
    }

    const courseRegex = /^[a-zA-Z0-9\s\-_.,()]{1,100}$/;
    for (const course of courseList) {
      if (!courseRegex.test(course)) {
        return res.status(400).json({ 
          success: false, 
          message: `Invalid course name format: ${course}. Only alphanumeric characters, spaces, and common punctuation are allowed.` 
        });
      }
    }
  
    let query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.middle_name,
        s.last_name, 
        s.email, 
        s.student_number, 
        s.course_name, 
        s.year_level, 
        s.gender, 
        s.birthdate,
        s.is_active,
        u.is_locked,
        u.locked_until
      FROM students s
      JOIN users u ON s.user_id = u.id
      WHERE s.course_name IN (`;

    const placeholders = courseList.map((_, index) => `$${index + 1}`).join(',');
    query += `${placeholders}) ORDER BY s.last_name ASC`;
    
    const result = await pool.query(query, courseList);
    
    return res.status(200).json(result.rows);
  } catch (error) {
    console.error("Error fetching students by courses:", error);
    return res.status(500).json({ 
      success: false, 
      message: "Failed to fetch students by courses",
      error: error.message 
    });
  }
};

exports.validateStudentByNumber = async (req, res) => {
  try {
    const { studentNumber } = req.query;
 
    
    if (!studentNumber) {
      return res.status(400).json({ 
        success: false, 
        message: "Student number is required" 
      });
    }
    
    // Validate student number format
    if (!/^02000[0-9]{6}$/.test(studentNumber)) {

      return res.status(400).json({
        success: false,
        message: "Invalid student number format. Must be 11 digits starting with 02000"
      });
    }
    
    // Query to find the student
    const query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.last_name, 
        s.student_number, 
        s.course_name,
        s.year_level,
        s.is_active
      FROM students s
      WHERE s.student_number = $1 AND s.is_active = TRUE
    `;
    
    const result = await pool.query(query, [studentNumber]);
    console.log(`Query results for ${studentNumber}:`, result.rows);
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Student not found or inactive"
      });
    }
    
    return res.status(200).json({
      success: true,
      student: result.rows[0]
    });
  } catch (error) {
    console.error("Error validating student:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to validate student",
      error: error.message
    });
  }
};

exports.searchStudents = async (req, res) => {
  try {
    const { term } = req.query;
    console.log(`Searching for students with term: ${term}`);
    
    if (!term || term.length < 4) {
      return res.status(400).json({ 
        success: false, 
        message: "Search term must be at least 4 characters" 
      });
    }
    
    // Search by student number (partial match)
    const query = `
      SELECT 
        s.id, 
        s.first_name, 
        s.last_name, 
        s.student_number, 
        s.course_name
      FROM students s
      WHERE s.student_number LIKE $1 AND s.is_active = TRUE
      ORDER BY s.student_number
      LIMIT 10
    `;
    
    const searchTerm = `%${term}%`;
    const result = await pool.query(query, [searchTerm]);
    console.log(`Search results for "${term}":`, result.rows);
    
    return res.status(200).json({
      success: true,
      students: result.rows
    });
  } catch (error) {
    console.error("Error searching students:", error);
    return res.status(500).json({
      success: false,
      message: "Failed to search students",
      error: error.message
    });
  }
};

exports.changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    const userId = req.user.id;


    if (!currentPassword || !newPassword) {
      return res.status(400).json({ message: "Current password and new password are required" });
    }

    const passwordRegex = /^(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    if (!passwordRegex.test(newPassword)) {
      console.log("Password validation failed");
      return res.status(400).json({ 
        message: "Password must be at least 8 characters long, include an uppercase letter, a number, and a special character." 
      });
    }

    try {
 
      const result = await changePassword(userId, currentPassword, newPassword);
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error in changePassword model:", error);
      if (error.message === "Current password is incorrect") {
        return res.status(401).json({ message: error.message });
      }
      if (error.message === "User not found") {
        return res.status(404).json({ message: error.message });
      }
      throw error; 
    }
  } catch (error) {
    console.error("Error in changePassword controller:", error);
    res.status(500).json({ 
      message: "Error changing password",
      error: error.message 
    });
  }
};
